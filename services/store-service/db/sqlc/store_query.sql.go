// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: store_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkCheckStock = `-- name: BulkCheckStock :many
SELECT 
    id,
    product_name,
    available_quantity,
    CASE 
        WHEN available_quantity >= $2 THEN true 
        ELSE false 
    END as can_fulfill
FROM store 
WHERE id = ANY($1::bigint[])
FOR UPDATE
`

type BulkCheckStockParams struct {
	Column1           []int64        `json:"column_1"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
}

type BulkCheckStockRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
	CanFulfill        bool           `json:"can_fulfill"`
}

func (q *Queries) BulkCheckStock(ctx context.Context, arg BulkCheckStockParams) ([]BulkCheckStockRow, error) {
	rows, err := q.db.Query(ctx, bulkCheckStock, arg.Column1, arg.AvailableQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkCheckStockRow
	for rows.Next() {
		var i BulkCheckStockRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.AvailableQuantity,
			&i.CanFulfill,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkStockAvailability = `-- name: CheckStockAvailability :many
SELECT 
    id,
    product_name,
    available_quantity,
    reserved_quantity,
    (available_quantity >= $2) as is_sufficient
FROM store 
WHERE id = ANY($1::bigint[])
FOR UPDATE
`

type CheckStockAvailabilityParams struct {
	Column1           []int64        `json:"column_1"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
}

type CheckStockAvailabilityRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
	ReservedQuantity  pgtype.Numeric `json:"reserved_quantity"`
	IsSufficient      bool           `json:"is_sufficient"`
}

func (q *Queries) CheckStockAvailability(ctx context.Context, arg CheckStockAvailabilityParams) ([]CheckStockAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, checkStockAvailability, arg.Column1, arg.AvailableQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckStockAvailabilityRow
	for rows.Next() {
		var i CheckStockAvailabilityRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.AvailableQuantity,
			&i.ReservedQuantity,
			&i.IsSufficient,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const confirmStockSale = `-- name: ConfirmStockSale :one
UPDATE store 
SET 
    reserved_quantity = reserved_quantity - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
  AND reserved_quantity >= $2
RETURNING id, product_name, available_quantity, reserved_quantity
`

type ConfirmStockSaleParams struct {
	ID               int64          `json:"id"`
	ReservedQuantity pgtype.Numeric `json:"reserved_quantity"`
}

type ConfirmStockSaleRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
	ReservedQuantity  pgtype.Numeric `json:"reserved_quantity"`
}

func (q *Queries) ConfirmStockSale(ctx context.Context, arg ConfirmStockSaleParams) (ConfirmStockSaleRow, error) {
	row := q.db.QueryRow(ctx, confirmStockSale, arg.ID, arg.ReservedQuantity)
	var i ConfirmStockSaleRow
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.AvailableQuantity,
		&i.ReservedQuantity,
	)
	return i, err
}

const releaseReservedStock = `-- name: ReleaseReservedStock :one
UPDATE store 
SET 
    available_quantity = available_quantity + $2,
    reserved_quantity = reserved_quantity - $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
  AND reserved_quantity >= $2
RETURNING id, product_name, available_quantity, reserved_quantity
`

type ReleaseReservedStockParams struct {
	ID                int64          `json:"id"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
}

type ReleaseReservedStockRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
	ReservedQuantity  pgtype.Numeric `json:"reserved_quantity"`
}

func (q *Queries) ReleaseReservedStock(ctx context.Context, arg ReleaseReservedStockParams) (ReleaseReservedStockRow, error) {
	row := q.db.QueryRow(ctx, releaseReservedStock, arg.ID, arg.AvailableQuantity)
	var i ReleaseReservedStockRow
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.AvailableQuantity,
		&i.ReservedQuantity,
	)
	return i, err
}

const reserveStock = `-- name: ReserveStock :one

UPDATE store 
SET 
    available_quantity = available_quantity - $2,
    reserved_quantity = reserved_quantity + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
  AND available_quantity >= $2
RETURNING id, product_name, available_quantity, reserved_quantity
`

type ReserveStockParams struct {
	ID                int64          `json:"id"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
}

type ReserveStockRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
	ReservedQuantity  pgtype.Numeric `json:"reserved_quantity"`
}

// Lock rows during transaction
func (q *Queries) ReserveStock(ctx context.Context, arg ReserveStockParams) (ReserveStockRow, error) {
	row := q.db.QueryRow(ctx, reserveStock, arg.ID, arg.AvailableQuantity)
	var i ReserveStockRow
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.AvailableQuantity,
		&i.ReservedQuantity,
	)
	return i, err
}

const restoreStock = `-- name: RestoreStock :one
UPDATE store 
SET 
    available_quantity = available_quantity + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, product_name, available_quantity, reserved_quantity
`

type RestoreStockParams struct {
	ID                int64          `json:"id"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
}

type RestoreStockRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	AvailableQuantity pgtype.Numeric `json:"available_quantity"`
	ReservedQuantity  pgtype.Numeric `json:"reserved_quantity"`
}

func (q *Queries) RestoreStock(ctx context.Context, arg RestoreStockParams) (RestoreStockRow, error) {
	row := q.db.QueryRow(ctx, restoreStock, arg.ID, arg.AvailableQuantity)
	var i RestoreStockRow
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.AvailableQuantity,
		&i.ReservedQuantity,
	)
	return i, err
}
